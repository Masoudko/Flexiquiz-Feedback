# -*- coding: utf-8 -*-
"""PEEWRITINGANALYSIS

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1A5iF5YomsSrEfHNwnn-K5rJVWhhU7lP4
"""

# Install required libraries
!pip install pdfplumber openai google-auth google-api-python-client
!pip install openai==0.28
!pip show openai

# Import necessary modules
from googleapiclient.discovery import build
from googleapiclient.http import MediaIoBaseDownload
from google.colab import drive
drive.mount('/content/drive')
from google.oauth2 import service_account
import pdfplumber
import openai
import smtplib
from email.mime.text import MIMEText
import io

# Step 1: Authenticate and Initialize Google Drive API
# Replace this placeholder with the path to your service account JSON file
SERVICE_ACCOUNT_FILE = "/content/drive/MyDrive/Flexiquiz Test Analysis/flexiquiz-automation-8e0fd34b66d0.json"

# Replace this placeholder with your Google Drive folder ID
FOLDER_ID = "Folder_ID"  # <--- Update with your folder ID

SCOPES = ['https://www.googleapis.com/auth/drive']

# Authenticate and initialize the Google Drive service
credentials = service_account.Credentials.from_service_account_file(SERVICE_ACCOUNT_FILE, scopes=SCOPES)
service = build('drive', 'v3', credentials=credentials)

processed_files = set()  # Track processed files to avoid duplicates

# Step 2: Fetch New Files from Google Drive
def fetch_new_files():
    """
    Fetch new PDF files from the specified Google Drive folder.
    :return: List of unprocessed files.
    """
    query = f"'{FOLDER_ID}' in parents and mimeType='application/pdf'"
    results = service.files().list(q=query, fields="files(id, name, modifiedTime)").execute()
    items = results.get('files', [])
    return [file for file in items if file['id'] not in processed_files]

# Step 3: Download File
def download_file(file_id, file_name):
    """
    Download a file from Google Drive and save it locally with a unique name.
    :param file_id: ID of the file to download.
    :param file_name: Name of the file.
    :return: Path to the downloaded file.
    """
    try:
        # Generate a unique file path using the file name and ID
        unique_name = f"{file_name.rsplit('.', 1)[0]}_{file_id[:8]}.pdf"
        file_path = f"/content/{unique_name}"

        # Download the file
        request = service.files().get_media(fileId=file_id)
        with io.FileIO(file_path, 'wb') as file:
            downloader = MediaIoBaseDownload(file, request)
            done = False
            while not done:
                _, done = downloader.next_chunk()
        print(f"File downloaded successfully: {file_path}")
        return file_path
    except Exception as e:
        print(f"Error downloading file {file_name}: {e}")
        return None

# Step 4: NEW Extract Content from PDF
def extract_pdf_content(file_path):
    """
    Extracts content from a PDF file and parses Point, Evidence, and Explanation.
    :param file_path: Path to the PDF file.
    :return: Dictionary with name, email, and response.
    """
    try:
        with pdfplumber.open(file_path) as pdf:
            # Extract text from all pages
            text = "".join(page.extract_text() for page in pdf.pages)

            # Normalize the text (remove extra spaces and line breaks)
            lines = [line.strip() for line in text.split("\n") if line.strip()]

            # Extract Name and Email
            name = next((line.split(" ", 1)[-1].strip() for line in lines if line.lower().startswith("name")), None)
            email = next((line.split(" ", 1)[-1].strip() for line in lines if line.lower().startswith("email")), None)

            # Extract Point, Evidence, and Explanation using specific keywords
            response = {"Point": None, "Evidence": None, "Explanation": None}
            keywords = {
                "1. Point": "Point",
                "2. Evidence": "Evidence",
                "3. Explanation": "Explanation"
            }

            for i, line in enumerate(lines):
                line_lower = line.strip().lower()
                for keyword, key in keywords.items():
                    if line_lower.startswith(keyword.lower()):  # Match case-insensitively
                        response[key] = (
                            lines[i + 1].strip() if i + 1 < len(lines) and lines[i + 1].strip() else None
                        )

            # Log extracted responses
            print(f"Extracted Name: {name}, Email: {email}, Response: {response}")
            return {"name": name, "email": email, "response": response}

    except Exception as e:
        print(f"Error extracting content from PDF: {e}")
        return {"name": None, "email": None, "response": None}



# pre-step 5 Define the marking criteria
criteria = {
    "Exceeding": [
        "proficiently use knowledge", "precise quotes", "intelligent conclusions",
        "perceptive comments about language", "effect on the reader"
    ],
    "Accomplished": [
        "spot a range of ideas", "relevant quotes", "intelligent conclusions",
        "examples of language", "language tricks"
    ],
    "Expected": [
        "find and understand main ideas", "support comments with good quotes",
        "begin developing comments", "describe the effect of word choices"
    ],
    "Emerging": [
        "find main ideas", "simple comments", "find quotes to prove ideas",
        "simple comments about language"
    ]
}


# Step 5: Generate Feedback Using OpenAI and Assign a Mark
def generate_feedback_and_mark(response):
    """
    Generate feedback using OpenAI and assign a grade based on the marking criteria.
    :param response: Dictionary containing Point, Evidence, and Explanation.
    :return: Feedback string and grade.
    """
    openai.api_key = "Open_AI_Key"  # Replace with your actual OpenAI API key

    # Construct the prompt for GPT
    prompt = f"""
    Provide feedback for the following response:

    Point: {response.get('Point', 'N/A')}
    Evidence: {response.get('Evidence', 'N/A')}
    Explanation: {response.get('Explanation', 'N/A')}

    Feedback should:
    1. Be clear and simple enough for an 11-year-old to understand.
    2. Be encouraging, highlighting strengths.
    3. Be constructive, offering suggestions for improvement.
    """

    # Use OpenAI ChatCompletion API to generate feedback
    try:
        completion = openai.ChatCompletion.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "You are an educational evaluator providing feedback on a student's PEE response."},
                {"role": "user", "content": prompt}
            ],
            max_tokens=300,
            temperature=0.7
        )
        feedback = completion['choices'][0]['message']['content'].strip()

        # Determine the grade based on the marking criteria
        grade = "Emerging"  # Default grade
        response_text = f"{response.get('Point', '')} {response.get('Evidence', '')} {response.get('Explanation', '')}".lower()
        for level, phrases in criteria.items():
            if any(phrase in response_text for phrase in phrases):
                grade = level
                break

        # Append grade to the feedback
        feedback += f"\n\nGrade: {grade}"
        print(f"Generated Feedback: {feedback}")  # Debug log
        return feedback, grade
    except openai.error.OpenAIError as e:
        print(f"OpenAI API error: {e}")
        return None, None




# Step 6: Send Feedback via Email
def send_email(name, student_email, feedback):
    """
    Send feedback to the teacher for approval before sending to the student.
    :param name: Student's name.
    :param student_email: Student's email.
    :param feedback: Feedback content.
    """
    sender_email = "results.flexiquiz@gmail.com"  # Your Gmail account
    app_password = "gmail_Password"  # Your Gmail app password
    teacher_email = "masoud.motlagh@cambridgeschool.eu"  # Teacher's email for approval

    subject = f"Approval Request: Feedback for {name}'s PEE Writing"
    body = f"""
    Dear Teacher,

    Below is the feedback generated for {name} based on their PEE writing task:

    Feedback:
    {feedback}

    Student's Email: {student_email}

    Please review and approve this feedback. Once approved, it can be sent directly to the student.

    Best regards,
    Your Automated System
    """

    try:
        msg = MIMEText(body)
        msg["Subject"] = subject
        msg["From"] = sender_email
        msg["To"] = teacher_email

        with smtplib.SMTP("smtp.gmail.com", 587) as server:
            server.starttls()
            server.login(sender_email, app_password)
            server.sendmail(sender_email, teacher_email, msg.as_string())
        print(f"Feedback sent to teacher for approval: {teacher_email}")
    except Exception as e:
        print(f"Error sending email: {e}")


# Main Execution
new_files = fetch_new_files()
if not new_files:
    print("No new files found.")
else:
    for file in new_files:
        print(f"Processing file: {file['name']}")
        file_path = download_file(file['id'], file['name'])
        if file_path:
            content = extract_pdf_content(file_path)
            if content:
                name, email, response = content.get("name"), content.get("email"), content.get("response")
                print(f"Response passed to generate_feedback_and_mark: {response}")
                if name and email and response:
                    # Generate feedback and determine grade
                    feedback, grade = generate_feedback_and_mark(response)
                    if feedback:
                        # Send the feedback with grade
                        send_email(name, email, feedback)
                        processed_files.add(file["id"])
                    else:
                        print(f"Failed to generate feedback for {file['name']}")
                else:
                    print(f"Failed to extract valid name, email, or response from {file['name']}")